# Результаты  
## Время на создание/работу с аттрибутами объекта:  
* Быстрее всего создаются (и прочие действия см ```time_profile_task_1.jpg```) объекты класса со слотами, на втором месте идет класс с обычными аттрибутами. Медленее всех оказался класс с wearkefs. Однако сложно на основании этих данных сделать корректные выводы, для более корректной оценки необходимо собрать статистику по каждому прогону и провести т-тест для сравнения средних.  
## Профилирование памяти:
* Как и ожидалось, меньшего всего памяти занимают объекты класса со слотами (см ```mem_profile_all.jpg```) ~ 96 Mb, объекты с обычными аттрибутами занимают почти вдвое больше (~181 Mb), объекты с weakref аттрибутами занимают больше всех (~195 Mb). Комментарии насчет т-теста уместны и здесь.  
## Профилировани запросов:  
* Как и в предыдущих случаях, лучше всего по скорости работы себя показали объекты со слотами (```call_profile_slots.jpeg```), на втором месте обычные объекты (```call_profile_ordinary.jpeg```), на третьем объекты с weakrefs (```call_profile_weak_refs.jpeg```).  
### P. S.  
Время из первого (наивного) профилирования отличается от результатов при профилировании вызовов, тк в первом случае объект создавался и сразу добавлялся в list через list comprehension, что по логике вещей увеличивает время работы скрипта по созданию объектов. В случае же профилирвоания вызовов, объект создавался, изменялся (его атрибуты) и перезаписывался на следующей итерации, т.е. я его не хранил, поэтому и время оказалось быстрее.
